### JPA(Java Persistence API)

---



##### :one: SQL을 직접 다룰 때 발생하는 문제점

- 객체를 DB에 CRUD하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야 함 -> 비슷한 일 반복 -> 지루함 + 생산성 감소
- DAO를 통해 어떤 SQL이 실행되고 있고, 어떠한 결과가 나오는지 일일이 확인해야함
- 강한 의존 관계 -> 연관성 증가
- 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 제한됨



##### :two: 패러다임 불일치

- 객체와 RDBMS가 지향하는 목적이 달라 둘의 기능과 표현 방법이 다름에서 발생하는 문제
- 객체 구조를 테이블 구조에 정하는데 한계가 존재함
- ex) 상속, 연관관계(객체=참조, 테이블=FK) 등



##### :three: JPA란?

- 자바 진영의 ORM 기술 표준
- 자바 애플리케이션과 JDBC 사이에서 동작

![jpa 구조]./photo\jpa 구조.png)



##### :four: ORM이란?

- Object-Relational Mapping
- 객체와 RDBMS를 매핑
- 객체와 테이블을 매핑해서 패러다임의 불일치 문제 해결
- 하이버네이트 : 대부분의 패런다임 불일치 문제를 해결해주는 성숙한 ORM 프레임워크(가장 많이 사용)



##### :five: JPA 사용 이유

1. 생산성
   - 반복적인 작업(쿼리 작성+JDBC API 사용) 감소

2. 유지보수
   - 의존성 감소로 인해 수정할 코드 라인수 감소

3. 패러다임 불일치 해결
4. 성능
   - 애플리케이션과 DB 사이에서 다양한 성능 최적화 기회 제공
5. 데이터 접근 추상화와 벤더 독립성
   - 애플리케이션과 DB 사이에 추상화된 데이터 접근 계층 제공 -> 특정 DB 기술에 종속되지않음



##### :six: JPA가 제공하는 CRUD API

1. 저장 기능
   - persist() : 객체를 DB에 저장, INSERT 쿼리

2. 조회 기능
   - find() : 객체 하나를 DB에서 조회, SELECT 쿼리

3. 수정 기능
   - 별도의 수정 메소드 제공하지 않음
   - 객체를 조회해서 값을 변경하면 트랜잭션을 커밋할 때 DB에 적절한 UPDATE 쿼리 전달

4. 연관 객체 조회



